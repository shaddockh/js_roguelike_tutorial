var Singletons = require('./singletons');
var Dictionary = require('entity-blueprint-manager').Dictionary;

var Entity = function (blueprint, blueprintOverrides) {
  this._loadBlueprint(blueprint, blueprintOverrides);
};

var noCopyList = {
  init: true,
  name: true,
  doc: true,
  type: true,
  obsolete: true
};

Entity.prototype._loadBlueprint = function (blueprint, blueprintOverrides) {
  //if the blueprint is coming in as just a name, then we need to look it up in
  //the blueprint catalog to get the actual blueprint
  if (typeof (blueprint) === 'string') {
    blueprint = Singletons.BlueprintCatalog.getBlueprint(blueprint, blueprintOverrides);
  }

  blueprint = blueprint || {};
  // Instantiate any properties from the passed object
  this._name = blueprint.name || '';

  // Create an object which will keep track what mixins we have
  // attached to this entity based on the name property
  this._attachedMixins = new Dictionary({
    ignoreCase: true
  });

  for (var componentKey in blueprint) {
    if (typeof (blueprint[componentKey]) === 'object') {
      //we have a component reference, grab it from the library and instantiate a mixin instance
      var mixin = Singletons.MixinCatalog.getMixin(componentKey);

      if (mixin.obsolete) {
        console.error('adding obsolete mixin: ' + componentKey + ' to ' + this._name);
      }
      this.attachMixin(mixin, blueprint[componentKey]);
    }
  }
};

Entity.prototype.attachMixin = function (mixin, blueprint) {

  // Copy over all properties from each mixin as long
  // as it's not the name or the init property. We
  // also make sure not to override a property that
  // already exists on the entity.
  for (var key in mixin) {
    if (mixin.hasOwnProperty(key)) {
      //Don't copy over any private properties or 'nocopy' items
      if (!noCopyList[key] && key[0] !== '_') {
        if (this.hasOwnProperty(key)) {
          console.error(this.getName() + ': Conflict attaching mixin property: ' + mixin.name + '.' + key + ' - property/method already exists.', this._attachedMixins);
        } else {
          this[key] = mixin[key];
        }
      }
    }
  }

  //add the name of this mixin to our attached mixins
  if (!this._attachedMixins.containsKey(mixin.name)) {
    this._attachedMixins.add(mixin.name);
  }
  //if a group name is present, add it
  if (mixin.type && !this._attachedMixins.containsKey(mixin.type)) {
    this._attachedMixins.add(mixin.type);
  }

  // Finally call the init function if there is one
  if (mixin.init) {
    mixin.init.call(this, blueprint);
  }
};

Entity.prototype.getName = function () {
  return this._name;
};

Entity.prototype.hasMixin = function (obj) {
  // Allow passing the mixin itself or the name as a string
  if (typeof obj === 'object') {
    return this._attachedMixins.containsKey(obj.name);
  } else {
    return this._attachedMixins.containsKey(obj);
  }
};

module.exports = Entity;
